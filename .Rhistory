pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
train_test_ids = split2ways(Default, 0.5)
train = train_test_ids$train
test = train_test_ids$test
# re-fit the logistic regression using only the training observations
glm.fit = glm(default ~ income + balance, data=Default, subset=train,
family=binomial)
# predict on the testing set, assign default to predicted probs > 0.5
probs = predict(glm.fit, Default[test, ], type="response")
pred = rep("No", length(probs))
pred[probs > 0.5] = "Yes"
# compute testing set error
mean(Default$default[test] != pred)
# now include the variable student
glm.fit2 = glm(default ~., data=Default, subset=train, family=binomial)
probs = predict(glm.fit2, Default[test,], type="response")
pred2 = rep("No", length(probs))
pred2[probs > 0.5] = "Yes"
mean(Default$default[test] != pred2)
glm.fit = glm(default ~ income + balance, data=Default, family=binomial)
summary(glm.fit)$coef
boot.fn = function(data, index) {
glm.fit = glm(default ~ income + balance, data=data, subset=index,
family=binomial)
coef(glm.fit)
}
boot(Default, boot.fn, 1000)
Weekly
library(ISLR)
?Weekly
glm.fit = glm(Direction ~ Lag1 + Lag2, data=Weekly, family=binomial)
summary(glm.fit)
glm.fit2 = glm(Direction ~ Lag1 + Lag2, data=Weekly,
family=binomial, subset=2:nrow(Weekly))
summary(glm.fit2)
head(Weekly[2:nrow(Weekly),])
head(Weekly[2:nrow(Weekly),], 2)
head(Weekly)
head(Weekly, 2)
head(Weekly[2:nrow(Weekly),], 2)
head(Weekly, 2)
prob = predict(glm.fit2, Weekly[1,], type="response")
pred = ifelse(prob>0.5, "Up", "Down")
table(Weekly$Direction[1], pred)
(1:10)[-2]
n = nrow(Weekly)
made_error = rep(0, n)
for (i in 1:n) {
train = (1:n)[-i]
glm.fit = glm(Direction ~ Lag1 + Lag2, data=Weekly,
subset=train, family=binomial)
prob = predict(glm.fit, Weekly[i, ])
pred = ifelse(prob > 0.5, "Up", "Down")
if (pred == Weekly$Direction[i])
made_error[i] = 1
}
mean(made_error)
set.seed(1)
y = rnorm(100)
x = rnorm(100)
y = x - 2*x^2 + rnorm(100)
plot(x, y)
plot(x, y)
dat = data.frame(y, x)
names(dat)
head(dat)
loocv
library(cabaceo)
?loocv
glm.fit = glm(y ~ x, data=dat)
glm.fit2 = glm(y ~ poly(x, 1), data=dat)
identical(glm.fit, glm.fit2)
summary(glm.fit)
summary(glm.fit2)
glm.fit2 = glm(y ~ poly(x, 1, raw=TRUE), data=dat)
summary(glm.fit)
summary(glm.fit2)
identical(glm.fit, glm.fit2)
coef(glm.fit2)
coef(glm.fit)
glm.fit1 = glm(y ~ poly(x, 1), data=dat)
glm.fit2 = glm(y ~ poly(x, 2), data=dat)
coef(glm.fit1)
coef(glm.fit2)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
glm.fit = glm(y ~ poly(x, d), data=dat)
error[d] = loocv(glm.fit)
}
error
set.seed(123)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
glm.fit = glm(y ~ poly(x, d), data=dat)
error[d] = loocv(glm.fit)
}
error
set.seed(123)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
glm.fit = glm(y ~ poly(x, d), data=dat)
error[d] = loocv(glm.fit)
}
error
set.seed(13)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
glm.fit = glm(y ~ poly(x, d), data=dat)
error[d] = loocv(glm.fit)
}
error
set.seed(132394)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
glm.fit = glm(y ~ poly(x, d), data=dat)
error[d] = loocv(glm.fit)
}
error
set.seed(132394)
error = rep(0, 4)
degree = 1:4
for (d in degree) {
fit = lm(y ~ poly(x, d), data=dat)
error[d] = loocv(fit)
}
error
summary(lm(y ~ poly(x, 1), data=dat))
summary(lm(y ~ poly(x, 2), data=dat))
summary(lm(y ~ poly(x, 3), data=dat))
summary(lm(y ~ poly(x, 4), data=dat))
library(MASS)
(mu_hat = mean(Boston$medv))
(se_hat = sd(Boston$medv) / sqrt(nrow(Boston)))
library(boot)
boot(Boston$medv, mean, 1000)
?boot
boot(Boston$medv, mean, 1000)
avg = function(x) mean(x, na.rm=T)
boot(Boston$medv, avg, 1000)
avg = function(x) mean(x)
boot(Boston$medv, avg, 1000)
avg = function(x) mean(x, na.rm=TRUE)
boot(Boston, avg, 1000)
boot(Boston$medv, avg, 1000)
Boston$medv
y = Boston$medv
boot(y, avg, 1000)
avg = function(x, idx) mean(x[idx])
boot(Boston$medv, avg, 999)
(se_hat = sd(Boston$medv) / sqrt(nrow(Boston)))
str(boot(Boston$medv, avg, 999))
boot(Boston$medv, avg, 999)[, "std. error"]
summary(boot(Boston$medv, avg, 999))
boot.res = boot(Boston$medv, avg, 999)
boot.res$statistics
summary(boot.res)$statistics
summary(boot.res)
boot.res$statistic
boot.res
str(boot.res)
str(summary(boot.res))
boot(Boston$medv, avg, 999)
boot_se = 0.4044819
(mu_hat = mean(Boston$medv))
c(-1, 1) * (mu_hat + 1.96 * boot_se)
t.test(Boston$medv)
(mu_hat + c(-1, 1) * 1.96 * boot_se)
(med_hat = median(Boston$medv))
boot(Boston$medv, med, 999)
med = function(x, idx) median(x[idx])
boot(Boston$medv, med, 999)
med_se = 0.3864519
boot.res = boot(Boston$medv, avg, 999)
boot.res
boot.res$data
quantile(boot.res$data, c(0.025, 0.975))
str(boot.res)
quantile(boot.res$t, c(0.025, 0.975))
(mu_hat + c(-1, 1) * 1.96 * boot_se)
t.test(Boston$medv)
boot_med = boot(Boston$medv, med, 999)
quantile(boot_med$t, 0.1)
pct10th = quantile(Boston$medv, 0.1)
(pct10th = quantile(Boston$medv, 0.1))
boot_pct = function(x, idx, q) quantile(x[idx], q)
boot(Boston$medv, boot_pct, q=0.1, R=999)
boot_pct = function(x, idx) quantile(x[idx], 0.1)
boot(Boston$medv, boot_pct, R=999)
set.seed(1)
boot_pct = function(x, idx, q) quantile(x[idx], q)
boot(Boston$medv, boot_pct, q=0.1, R=999)
set.seed(1)
boot_pct = function(x, idx) quantile(x[idx], 0.1)
boot(Boston$medv, boot_pct, R=999)
library(devtools)
proj_path = file.path(Sys.getenv("HOME"), "openCPU/apps")
setwd(file.path(proj_path, "phph"))
document()
document()
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
library(phph)
library(opencpu)
opencpu$stop()
cleanup()
opencpu$start(2498)
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
library(phph)
opencpu$stop()
cleanup()
opencpu$start(2498)
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
library(phph)
opencpu$stop()
cleanup()
opencpu$start(2498)
document()
opencpu$stop()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
document()
getwd()
document()
document()
document()
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
document()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
library(phph)
opencpu$stop()
cleanup()
opencpu$start(2498)
document()
document()
library(devtools)
proj_path = file.path(Sys.getenv("HOME"), "openCPU/apps")
setwd(file.path(proj_path, "phph"))
document()
file.edit("DESCRIPTION")
options(devtools.desc.title="'PHPH Cure Model Demo'")
file.edit("DESCRIPTION")
library(devtools)
options(devtools.desc.author="'Guangming Lang <gmlang@cabaceo.com> [aut, cre]'")
options(devtools.desc.license="MIT")
proj_path = file.path(Sys.getenv("HOME"), "openCPU/apps")
setwd(file.path(proj_path, "phph"))
file.edit("DESCRIPTION")
options(devtools.desc.author="'Guangming Lang <gmlang@cabaceo.com>'")
file.edit("DESCRIPTION")
document()
library(devtools)
options(devtools.desc.author="'Guangming Lang <gmlang@cabaceo.com>'")
options(devtools.desc.license="MIT")
proj_path = file.path(Sys.getenv("HOME"), "openCPU/apps")
create(file.path(proj_path, "phph"))
setwd(file.path(proj_path, "phph"))
use_package("survival")
use_package("splines")
use_data_raw()
file.edit("DESCRIPTION")
document()
document()
document()
opencpu$stop()
cleanup()
install.packages("/Users/gmlang/openCPU/apps/phph", repos=NULL, type="source")
library(phph)
library(opencpu)
opencpu$stop()
cleanup()
opencpu$start(2498)
130*12
300*356
200*356
250*356
110*12
157.5/7
2^40
2^30
1+p*(p-1)/2
p=30
1+p*(p-1)/2
150*365
200*365
225*365
250*365
300*365
350*365
14590 - 21425
14590 - 21425
366/2
366/4
115*12
10*90
20*90
684*2.49/100
684*2.49/100
